# frozen_string_literal: true

name "transforms"
version "0.1"

import_types_from "transformsTypes.hpp"

import_types_from "std"
import_types_from "base"

typekit.export_types "/transforms/PoseDivergence"

# Task that changes the source frame of a pose and twist combination expressed
# as RigidBodyState
#
# This task changes the source frame of a RBS, keeping the target frame the same.
# It can for instance provide a body2world transform from a imu2world transform
# and a body2imu generated by the transformer
#
# The reference frame is immaterial to these transformations and therefore does not
# need to be provided
task_context "PoseAndTwistFrameChangeRBSTask" do
    needs_configuration

    # The pose+velocity of the source frame w.r.t. the reference frame
    input_port "source2ref_samples", "/base/samples/RigidBodyState"

    # The pose+velocity of the target frame w.r.t. the reference frame
    output_port "target2ref_samples", "/base/samples/RigidBodyState"

    transformer do
        transform "source", "target"
        align_port "source2ref_samples"
        # Note: will have to be configured in the component's configuration file
        max_latency 1
    end

    port_driven
end

# Task that changes the reference frame of a pose expressed as RigidBodyState
#
# This task changes the reference frame of a RBS, keeping the source frame the same.
task_context "PoseReferenceChangeRBSTask" do
    needs_configuration

    # The pose of the source frame w.r.t. the reference frame
    input_port "source2ref_samples", "/base/samples/RigidBodyState"

    # The pose of the source frame w.r.t. the new reference frame
    output_port "source2new_ref_samples", "/base/samples/RigidBodyState"

    transformer do
        transform "new_ref", "ref"
        align_port "source2ref_samples"
        # Note: will have to be configured in the component's configuration file
        max_latency 1
    end

    port_driven
end

# Task that takes two poses relative to a single reference and outputs the one
# relative to the other
#
# 'newref' is considered fixed in 'ref' for this calculation. That is, the
# linear velocity is rotated to match b's orientation, but the velocities are
# not combined
task_context "PoseCombinationRBSTask" do
    needs_configuration

    input_port "object2ref_pose", "/base/samples/RigidBodyState"
    input_port "newref2ref_pose", "/base/samples/RigidBodyState"

    output_port "object2newref_pose", "/base/samples/RigidBodyState"
    port_driven
end

# Task for swithing between a main and a secondary rigid body state source. It forwards
# the main source by default. The sencondary source is forwarded only when:
#   - main source timeout
#   - main source invalid data
#   - main source is valid, but waiting for stabilization within hysteresis period after
#     a timeout or invalid samples
# If the component is at hysteresis wait state and the secondary source goes invalid, it
# goes back to main source right away, not waiting for histeresys period termination
task_context "RedundantRBSSelectorTask" do
    needs_configuration

    # How long the component should wait after its start to evaluate whether
    # it has missing inputs
    property "init_timeout", "/base/Time"

    # How long without valid data on a port before the source is considered
    # invalid
    #
    # It needs to be set to a low value, but still has to be a significant
    # number of the source periods
    property "source_timeout", "/base/Time"

    # When the main source becomes valid again, the component will make sure it
    # remains valid for this long until it switches back to main
    #
    # This is to avoid rapid main/secondary switching if the main source is
    # unstable. The switch is instantaneous if the secondary source becomes
    # invalid
    #
    # This should be relatively high (e.g. 30s)
    property "main_source_histeresys", "/base/Time"
    property "position_threshold", "double"
    property "orientation_thresholds", "/std/vector<double>"

    input_port "main_rbs_source", "/base/samples/RigidBodyState"
    input_port "secondary_rbs_source", "/base/samples/RigidBodyState"

    output_port "rbs_out", "/base/samples/RigidBodyState"
    # Returns if two pose sources are outside thresholds
    output_port "pose_divergence", "/transforms/PoseDivergence"

    # Initial state. Both sources ok, main is being forwarded.
    runtime_states :BOTH_SOURCES_VALID

    # Both sources are ok, but the secondary source is the one being forwarded. The
    # component is waiting the hysteresys period so it can go back forwarding main source.
    runtime_states :MAIN_SOURCE_RECOVERING

    # Main source is invalid due timeout or invalid data. Secondary is being forwarded
    runtime_states :INVALID_MAIN_SOURCE

    # Secondary source is invalid or timeout
    runtime_states :INVALID_SECONDARY_SOURCE

    # Both sources are invalid or timeout
    exception_states :NO_VALID_SOURCES

    port_driven timeout: 0.02
end
